
kheloyarpanel@gmail.com
#$%^dHGD5565ee


aPanel Internet Address: https://147.93.152.111:25563/d7583f79
aaPanel Internal Address: https://147.93.152.111:25563/d7583f79
username: knpaltha
password:Â 914c7aea
amazon q cli warp cli





Matrimonial App Architecture: Shaadi.com/BharatMatrimony Clone
This document outlines a comprehensive architectural structure for building a matrimonial application similar to Shaadi.com or BharatMatrimony, leveraging the technologies you've specified: React Native (Expo), Firebase, Node.js (Express), MongoDB, and React.js for the Admin Panel.

1. Overall Architecture Overview
The application will follow a microservices-oriented or a well-structured monolithic architecture, with clear separation of concerns between the frontend (mobile app, admin panel) and the backend.

Client-Side:

React Native (Expo): The primary mobile application for users.

React.js: A dedicated web-based admin panel for managing users, profiles, content, and other administrative tasks.

Backend:

Node.js (Express.js): The core API server handling business logic, data interactions, and serving requests from both the mobile app and the admin panel.

Database:

MongoDB: A NoSQL document database for storing all application data.

External Services:

Firebase: Primarily for push notifications, and potentially for authentication (if integrated) or other real-time features.

graph TD
    A[React Native Mobile App (Expo)] -->|REST API Calls| B(Node.js Backend)
    C[React.js Admin Panel] -->|REST API Calls| B
    B -->|Database Operations| D[MongoDB Database]
    B -->|Push Notifications| E[Firebase Cloud Messaging]
    E --> A
    A -->|Authentication (Optional)| F[Firebase Auth]
    C -->|Authentication (Optional)| F

2. Core Components & Their Responsibilities
2.1. React Native Mobile App (Expo)
This is the user-facing application for Android and iOS.

Technology Stack:

Framework: React Native

Toolchain: Expo (for simplified development, build, and deployment)

UI Library: React Native Paper, NativeBase, or a custom design system.

State Management: React Context API, Zustand, or Redux Toolkit.

Networking: Axios or Fetch API.

Navigation: React Navigation.

Push Notifications: Expo Notifications API (integrates with Firebase FCM).

Image Handling: Expo ImagePicker, Expo MediaLibrary.

Google Sign-In: @react-native-google-signin/google-signin (or Expo's expo-auth-session for web-based authentication flows).

Key Responsibilities:

User registration and login (including Google Login).

Profile creation, editing, and viewing.

Browsing and searching for profiles based on various criteria (filters).

Viewing profile details, photos.

Sending/receiving interest requests, messages.

Managing matches and connections.

Payment gateway integration (for premium features).

Receiving and displaying push notifications.

Settings and preferences management.

User authentication and session management.

2.2. Firebase (for Push Notifications)
Firebase will primarily be used for sending real-time push notifications to users.

Service: Firebase Cloud Messaging (FCM).

Integration:

React Native: Expo Notifications handles the client-side integration with FCM. You'll register device tokens and send them to your Node.js backend.

Node.js Backend: Use the Firebase Admin SDK to send targeted push notifications to specific device tokens or topics.

Key Responsibilities:

Delivering notifications for new messages, interest requests, profile views, matches, etc.

Managing device registration tokens.

Handling notification payload and data.

2.3. Node.js Backend (Express.js)
This is the central brain of your application, handling all business logic and data interactions.

Technology Stack:

Runtime: Node.js

Web Framework: Express.js

Database ODM/Driver: Mongoose (for MongoDB object modeling) or native MongoDB driver.

Authentication: JSON Web Tokens (JWT) for stateless authentication. Passport.js can be used for strategies. For Google Login token verification, google-auth-library will be used.

Validation: Joi or Express-validator.

File Uploads: Multer (for handling profile photos, documents).

Environment Variables: dotenv.

Logging: Winston or Morgan.

Push Notification SDK: Firebase Admin SDK.

Email/SMS: Nodemailer, Twilio (optional, for verification/alerts).

Payment Gateway Integration: SDKs for Stripe, Razorpay, or similar.

Key Responsibilities:

API Endpoints: Exposing RESTful APIs for all mobile app and admin panel functionalities.

User Management: Registration, login, profile creation, password management, account activation, handling Google Sign-In authentication.

Profile Management: CRUD operations for user profiles, including photos, preferences, partner expectations.

Search & Filtering: Implementing robust search algorithms and filtering options.

Interest & Messaging: Handling interest requests, message exchange, chat history.

Matchmaking Logic: Implementing algorithms to suggest compatible profiles.

Payment & Subscription: Managing premium memberships, payment processing, transaction history.

Notification Management: Triggering and sending push notifications via Firebase.

Admin Operations: APIs for admin panel functionalities (user blocking, content moderation, analytics).

Security: Authentication (JWT, Google token verification), authorization (role-based access control), input validation, data encryption.

Error Handling: Robust error reporting and graceful error responses.

2.4. MongoDB Database
A NoSQL document database, ideal for flexible schema and scaling.

Technology: MongoDB

Key Collections (Examples):

users: Stores core user authentication details (email, password hash, roles, googleId if using Google Login).

profiles: Stores detailed matrimonial profiles (personal info, family, education, professional, lifestyle, photos, partner preferences). This might be linked to users by _id.

interests: Records interest requests between users (sender, receiver, status: pending, accepted, rejected).

messages: Stores chat messages between users (sender, receiver, content, timestamp).

subscriptions: Manages user subscription plans and their expiry.

transactions: Records payment transactions.

notifications: Stores notification history for users.

reports: For user-reported content/profiles.

admin_logs: For tracking admin actions.

Key Responsibilities:

Storing all application data in a structured yet flexible manner.

Ensuring data integrity and consistency.

Providing efficient data retrieval for search and filtering.

2.5. React.js Admin Panel
A web-based interface for administrators to manage the application.

Technology Stack:

Framework: React.js

UI Framework: Material-UI, Ant Design, or a custom admin template.

State Management: React Context API, Zustand, or Redux Toolkit.

Networking: Axios or Fetch API.

Routing: React Router DOM.

Authentication: JWT-based authentication with the Node.js backend.

Charting/Reporting: Recharts, Chart.js (for analytics dashboards).

Key Responsibilities:

User Management: View, edit, activate, deactivate, block users/profiles.

Profile Moderation: Review and approve new profiles/photos, handle reported content.

Content Management: Manage static content, FAQs, terms & conditions.

Subscription & Payment Management: View subscriptions, manage plans, track payments.

Analytics & Reporting: Dashboards for user growth, active users, matches, revenue.

Notification Management: Ability to send broadcast notifications or targeted notifications.

Settings: Manage application-wide settings.

Admin Role Management: (Optional) Manage different admin roles and permissions.

3. Key Features/Modules
Here's a breakdown of essential features and where they fit:

User Authentication & Authorization:

Mobile/Admin: User registration, login (including Google Login), logout, password reset.

Backend: JWT generation/validation, Google ID token verification, role-based access control (RBAC).

Profile Management:

Mobile: Create/edit detailed profiles (personal, family, education, professional, lifestyle, photos).

Admin: Profile review, approval, editing, blocking.

Backend: API for CRUD operations on profiles, image upload handling.

Database: profiles collection.

Search & Discovery:

Mobile: Advanced search filters (age, height, religion, caste, location, education, profession, etc.).

Backend: Complex MongoDB queries, indexing for performance.

Interest & Messaging System:

Mobile: Send/accept/decline interests, real-time chat.

Backend: APIs for interest management, message storage, potentially WebSockets for real-time chat (beyond basic REST).

Database: interests, messages collections.

Firebase: Push notifications for new interests/messages.

Matchmaking & Recommendations:

Backend: Logic to suggest compatible profiles based on user preferences and profile data.

Mobile: Displaying recommended profiles.

Premium Features & Payments:

Mobile: Display premium plans, initiate payment flow.

Backend: Payment gateway integration, subscription management.

Database: subscriptions, transactions collections.

Notifications:

Mobile: In-app notifications, push notifications.

Backend: Logic to trigger notifications based on events (new message, interest accepted, profile view), Firebase FCM integration.

Firebase: Delivery of push notifications.

Reporting & Blocking:

Mobile: Users can report inappropriate profiles.

Backend: APIs to handle reports, block users.

Admin: Review and act on reported profiles.

Settings & Privacy:

Mobile: User privacy settings (who can view profile, contact preferences).

Backend: Enforcing privacy rules.

4. High-Level Data Models (MongoDB Collections)
users Collection
{
    "_id": ObjectId("..."),
    "email": "user@example.com",
    "passwordHash": "...", // Hashed password (for traditional login)
    "phoneNumber": "+919876543210",
    "isVerified": {
        "email": true,
        "phone": true
    },
    "role": "user", // "user", "admin"
    "googleId": "...", // New: Google user ID if authenticated via Google
    "authProvider": "email_password", // New: "email_password", "google"
    "createdAt": ISODate("..."),
    "updatedAt": ISODate("...")
}

profiles Collection
{
    "_id": ObjectId("..."),
    "userId": ObjectId("..."), // Link to users collection
    "fullName": "Priya Sharma",
    "gender": "Female",
    "dateOfBirth": ISODate("1995-05-15T00:00:00Z"),
    "height": "5'4\"", // Or in cm
    "maritalStatus": "Never Married",
    "religion": "Hindu",
    "caste": "Brahmin",
    "subCaste": "Saraswat",
    "motherTongue": "Hindi",
    "raasi": "Cancer",
    "manglik": "No",
    "education": {
        "degree": "B.Tech",
        "field": "Computer Science",
        "college": "IIT Delhi"
    },
    "profession": {
        "occupation": "Software Engineer",
        "company": "Google",
        "annualIncome": "15-20 Lakhs"
    },
    "location": {
        "city": "Bangalore",
        "state": "Karnataka",
        "country": "India"
    },
    "familyDetails": {
        "fatherStatus": "Retired",
        "motherStatus": "Homemaker",
        "brothers": 1,
        "sisters": 0,
        "familyType": "Nuclear",
        "familyValues": "Traditional"
    },
    "lifestyle": {
        "diet": "Vegetarian",
        "smoking": "No",
        "drinking": "No"
    },
    "aboutMe": "A brief description about the user...",
    "photos": [
        "url_to_photo1.jpg",
        "url_to_photo2.jpg"
    ],
    "partnerPreferences": {
        "ageRange": { "min": 28, "max": 32 },
        "heightRange": { "min": "5'6\"", "max": "5'10\"" },
        "maritalStatus": ["Never Married"],
        "religion": ["Hindu"],
        "caste": ["Brahmin", "Kshatriya"],
        "education": ["B.Tech", "M.Tech"],
        "profession": ["Software Engineer", "Doctor"],
        "location": ["Bangalore", "Chennai"],
        "diet": ["Vegetarian"]
    },
    "isApproved": false, // For admin moderation
    "isActive": true,
    "lastLogin": ISODate("..."),
    "updatedAt": ISODate("...")
}

interests Collection
{
    "_id": ObjectId("..."),
    "senderId": ObjectId("..."), // Link to profiles.userId
    "receiverId": ObjectId("..."), // Link to profiles.userId
    "status": "pending", // "pending", "accepted", "rejected", "withdrawn"
    "createdAt": ISODate("..."),
    "updatedAt": ISODate("...")
}

messages Collection
{
    "_id": ObjectId("..."),
    "senderId": ObjectId("..."), // Link to profiles.userId
    "receiverId": ObjectId("..."), // Link to profiles.userId
    "content": "Hi, I liked your profile!",
    "timestamp": ISODate("..."),
    "read": false
}

5. High-Level API Endpoints (Node.js/Express)
User & Authentication
POST /api/auth/register

POST /api/auth/login

POST /api/auth/google-login (New: For Google Sign-In)

POST /api/auth/forgot-password

POST /api/auth/reset-password

GET /api/auth/me (Protected)

Profiles
POST /api/profiles (Create profile - Protected)

GET /api/profiles/:id (Get single profile - Protected)

PUT /api/profiles/:id (Update profile - Protected)

DELETE /api/profiles/:id (Delete profile - Protected)

POST /api/profiles/search (Search profiles - Protected)

POST /api/profiles/upload-photo (Upload profile photo - Protected)

Interests
POST /api/interests (Send interest - Protected)

GET /api/interests/sent (Get sent interests - Protected)

GET /api/interests/received (Get received interests - Protected)

PUT /api/interests/:id/accept (Accept interest - Protected)

PUT /api/interests/:id/reject (Reject interest - Protected)

Messages
GET /api/messages/:userId (Get chat history with a user - Protected)

POST /api/messages (Send a message - Protected)

Subscriptions & Payments
GET /api/plans (Get available subscription plans)

POST /api/subscribe (Initiate subscription - Protected)

POST /api/payment/webhook (Payment gateway webhook for status updates)

Admin Endpoints (Protected by Admin Role)
GET /api/admin/users (Get all users)

PUT /api/admin/users/:id/status (Activate/Deactivate user)

GET /api/admin/profiles/pending-approval

PUT /api/admin/profiles/:id/approve

GET /api/admin/reports (View user reports)

POST /api/admin/notifications/send-broadcast

6. Authentication & Authorization Flow
User Registration/Login (Traditional):

Mobile app sends credentials to Node.js backend.

Backend authenticates (e.g., checks against MongoDB).

If successful, backend generates a JWT (JSON Web Token) containing user ID and role.

JWT is sent back to the mobile app.

Google Login Flow (New):

Client-Side (React Native):

The React Native app initiates the Google Sign-In process using @react-native-google-signin/google-signin (or Expo's expo-auth-session).

Upon successful login, Google returns an idToken (Google ID Token) and user information.

The idToken is then sent to your Node.js backend via a new API endpoint (e.g., POST /api/auth/google-login).

Backend-Side (Node.js):

The Node.js backend receives the idToken.

It uses the google-auth-library to verify the idToken with Google's authentication servers. This ensures the token is valid and hasn't been tampered with.

Once verified, the backend extracts the user's Google ID and email from the token payload.

It then checks if a user with this Google ID or email already exists in your users MongoDB collection.

If the user exists, their record is updated (e.g., lastLogin).

If the user does not exist, a new user record is created in your users collection, storing their Google ID and marking authProvider as "google".

Finally, your Node.js backend generates its own JWT for this user, containing your application's user ID and role. This JWT is sent back to the mobile app.

Subsequent Requests:

Mobile app stores the application's JWT (e.g., in secure storage like AsyncStorage for React Native).

For every protected API call, the mobile app includes this JWT in the Authorization header (Bearer <token>).

Node.js backend middleware verifies the JWT:

Checks if the token is valid and not expired.

Extracts user ID and role from the token.

Attaches user info to the request object (req.user).

Authorization middleware then checks req.user.role to ensure the user has permission for the requested action (e.g., only admins can access /api/admin routes).

7. Deployment Considerations
React Native (Expo):

Use Expo Application Services (EAS) for building and submitting to Google Play Store and Apple App Store.

Node.js Backend:

Cloud Platforms: AWS EC2/ECS/Lambda, Google Cloud Run/Compute Engine, Azure App Service, Heroku, DigitalOcean.

Containerization: Docker for consistent deployment.

Load Balancers: For scalability and high availability.

CI/CD: GitHub Actions, GitLab CI, Jenkins for automated testing and deployment.

MongoDB:

MongoDB Atlas (managed cloud service) is highly recommended for production.

Self-hosted MongoDB on a dedicated server.

React.js Admin Panel:

Static hosting: Netlify, Vercel, AWS S3 + CloudFront, Firebase Hosting.

This structure provides a robust foundation for building your matrimonial application. Each component plays a vital role, and careful planning and implementation within each will be key to the success of the project.